## 1 最大堆
- 是完全二叉树，每个父节点不小于子节点
- 不是二叉搜索树
- 完全二叉树可以由数组隐式表述
- 构造时，直接由数组构造，然后从最后的父节点开始，从底往上交换值
- 插入一个节点：插入下一个位置，位置是固定的，然后从底往上进行整理
- 删除一个节点：只能删除根结点，即最大值，将最后一个值替换到根结点，然后自顶向下进行整理
- 复杂度：整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。

## 2 快速排序
- 分治法：先找一个数，分左右，再在左右中找两个数分左右
- 在同为O(N*logN)的几种排序方法中效率较高

## 3 冒泡排序
- 交换相邻的数，每次把最大的放在后面
- O(N^2)

## 4 选择排序
- 每一次遍历选择最值进行交换，即把最值放在开始或者最后
- 与冒泡排序的区别在于，冒泡是相邻俩俩交换，而选择排序只有选到了最值才会交换

## 5 归并排序
- 速度仅次于快速排序
- 先排序小组，然后合并，直到所有元素
- 与快排都是分治法

## 6 插入排序
- 每次把一个元素插入已经有序的列表中

## 7 希尔排序
- 为方便记忆算法，我习惯将其记作“三层for循环+if” ------** for（for（for（if）））**
- 希尔排序针对插入排序的缺点：
  - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
  - 插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位
- https://blog.csdn.net/qq_39207948/article/details/80006224
- 第一个增量=数组的长度/2
- 第二个增量= 第一个增量/2
- 第三个增量=第二个增量/2
- 以此类推，最后一个增量=1
- 每次分成两两小组，进行排序，最后当增量为1时最后一次排序

## 8 桶排序
- 开链哈希表
- 数据分布相对比较均匀或者数据跨度范围并不是很大时

## 9 排序算法的稳定性
## 10 排序算法的代码

https://www.cnblogs.com/eniac12/p/5329396.html