# 整理所有的数据结构

## 0 序列式容器:ordered 而非 sorted
- array
- vector
- heap
- priority-queue
- list
- deque
- stack（deque adapter）
- queue（deque adapter）

### 0.1 array
### 0.2 vector
- 删除元素后空间不会缩减
- 单向开口的连续线性空间
### 0.3 list
- list是双向琏表
### 0.4 deque
- 双向开口的**分段**连续线性空间，头尾两端都可以进行删除和插入
- 有一个区域全是指针，指向分段的空间
- push_front pop_front
- push_back pop_back
- clear
- erase

- insert

### 0.5 stack
- 先进后出
- 没有迭代器
- 可以由deque形成，也可以由list形成

### 0.6 queue
- 先进先出
- 没有迭代器
- 可以用deque形成，也可以由list作为底层容器

### 0.7 priority queue
- 允许用户以任何次序将元素推入容器中，但是取出时从最大值开始取，binary max heap正是具有这样的特性
- 没有用二叉平衡搜索树实现
- 而binary heap是一种完全二叉树，只有底层叶节点从左到右不能有空隙
- 完全二叉树没有任何节点漏洞，因此可以使用array存储所有节点
- **完全二叉树的数组表达：**


## 1 关联式容器
- 每个元素都有：key + value
- 插入元素时根据 key 的大小，将元素放在合适的位置
- 关联式容器没有头尾，只有最大元素和最小元素
- 一般来说，关联式容器内部结构是一个平衡二叉树
- 平衡二叉搜索树：AVL-tree，RB-tree，AA-tree，其中被最广泛运用的是RB-tree**问题：这些树是什么玩意儿**
- 二叉搜索树：任意节点的左节点小于当前节点，右节点大于当前节点，十分方便搜索，但是，有退化成排序琏表的可能性，于是平衡二叉数产生了
- 平衡二叉树：任意节点的左子树和右子树的高度相差至多1，每次删除和插入都使用旋转来调整树，其中外侧插入使用单旋转，内侧插入使用双旋转，由于旋转操作频次很高，产生了红黑树。二叉平衡搜索树的搜索时间为对数时间
- 红黑树：红黑树没有平衡二叉树那么平衡，仅使用一些限定条件来达成相对平衡
- 完全二叉树：最大最小堆

### 1.0 RB-tree （红黑树，非公开）
- set和map的底层机制均为红黑树
1. 根节点为黑 
2. 红节点后为黑 
3. 任意节点的所有路径都有相同数量的黑节点 
4. 所有节点要么黑要么红
- 旋转操作会少于平衡二叉树
- 红黑树有一些操作：
  - 插入：insert_unique(), insert_equal()
  - 旋转及改变颜色
  - 搜索：find

### 1.1 set 集合
- 元素的key和value相同，不允许两个元素有相同的key
- 提供的算法：
  - 求交集：set_intersection
  - 联集：set_union
  - 差集：set_difference
  - 对称差集：set_symmetric_difference
- set的所有操作，都只是在调用红黑树的接口
- 衍生体： multiset（多键集合）
  - 和set唯一的差别在于允许键值重复
  - 插入操作使用的insert_equal()而不是insert_unique()


### 1.2 map 映射表
- 元素通过key自动排序
- map的所有元素都是pair，同时拥有key和value，pair的第一元素为key，第二元素为value，不能修改key但是可以修改value
- 不允许两个元素有相同的key
- map的所有操作，都只是在调用红黑树的接口
- 衍生体： multimap（多键映射表）
  - 和map唯一的差别在于允许键值重复
  - 插入操作使用的insert_equal()而不是insert_unique()

### 1.3 hash table 
- 哈希表也可以实现常数时间的查找
- 哈希表可以存储所有“有名字的项”
- 一个表格，一一对应的存储值，即哈希表，为了保证哈希表大小可控，需要使用映射函数来求位置
- 负载系数：元素个数/表格大小，负载系数应该在0-1之间，开链除外
- 但是如果两个元素映射到了一个地方（collision），如何解决？
  - 线性探测：使用 hash function计算出来的位置已经被占用，那么 +1 寻找，直到找到下一个空位。线性探测会造成 primary clustering 的问题
  - 二次探测：为了解决 primary clustering 的问题，使用 H+1*1 H+2*2 ... H+i*i 的方式依次搜索可用位置；如果表格大小为质数，且永远保持负载系数在0.5以下，则可以确定每次探测次数不超过2；**二次探测效果是较好的**
  - 复式散列；二次探测可以消除 primary clustering 的问题，但是可能造成secondary clustering的问题，即两个元素算出来的位置相同，那么探测的位置也会相同
  - 开链：与二次探测分庭抗礼的是separate chaining，每个格子中维护一个list，如果list够短的话，速度还是会快，负载会大于1
  - 等
- 哈希表的删除：惰性删除，待表格重新整理的时候才会删除，因为一个元素会影响其他元素的排列
- primary clustering：插入成本的增长，远高于负载系数的增长，即插入耗时长，搜索也会很慢

- hash_set
  - 使用哈希表实现的set，没有排序功能，但是搜索元素还是可以的
  - 使用方式与set相同
- hash_map
  - 没有排序功能
  - 其他与map相同
  - 下同
- hash_multiset
- hash_multimap

- unorder_map: hashtable + bucket,即 开链哈希表

## 迭代器

# 整理问题

1. STL容器各自的优缺点
- vector: 高效的存取，不擅长插入和删除，因为是数组
- list：高效插入和删除，低效访问，因为是双向琏表
- deque：两端都可以插入和删除，随机存取，double-ended queue 的缩写，又称双端队列容器，是数组和琏表的结合体，即一段一段的连续空间
- map：key-map，一对一，红黑树
- multimap：一对多，红黑树
- set：某个元素是否唯一存在于一个集合中，红黑树
- multiset：某个元素是否不唯一的存在于一个集合中，红黑树

2. **适配器是什么**

3. 哪些容器有迭代器，哪些没有？

4. stl是什么，有什么优点
- stl包括容器和算法，以及融合容器和算法的迭代器
- 容器分为两类：序列式和关联式
- 序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist
- 关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap
- 迭代器是STL的精髓：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计

5. 哈希树？
- 为查找而生，查找效率高于二叉平衡搜索树，哈希表，红黑树
- 质数分辨定理：
- 余数分辨定理：
- 线性分辨算法：
- 非线性分辨算法：

6. 字典树？

字典树如何优化？
答：字典树也是空间换时间的数据结构（哈希表是典型的空间换时间），一般优化方向就是：空间优化。

常用优化方法是：使用哈希表替换每个节点中指向孩子的指针数组，在建立字典树时根据需要向哈希表中添加指针，从而避免有些指针数组方式中的多余指针元素浪费空间。

7. B树？

7.1 B+ 树
7.2 B*树
7.3 R树

8. 哈夫曼树

9. 深度优先搜索，广度优点搜索

10. 二叉树的遍历

https://blog.csdn.net/wannuoge4766/article/details/83998377

有点不懂了，怎么有的是旋转来调整树形，有的是用的交换？？
小根堆用的交换吗？
需要查书


priority_queue是什么