
## 1. 智能指针的作用
- 智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源
- 智能指针代码实现： 用两个类来实现智能指针的功能，一个是引用计数类，另一个则是指针类

## 2. 智能指针的种类
- shared_ptr
- unique_ptr
- weak_ptr
- auto_ptr 

### 2.1 shared_ptr 
- 实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源
- 1. 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
- 2. 每次创建类的新对象时，初始化指针并将引用计数置为1
- 3. 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
- 4. 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数**没看懂**
- 5. 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。

### 2.2 unique_ptr 
- unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空
- 所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中
- 局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）
- 如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃
- 即不进行计数，如果调用unique_ptr的析构函数，则析构基础对象

### 2.3 weak_ptr 
- 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放
- weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数
- 如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放
- 所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针
- 已经被unique_ptr所替代了

### 2.4 auto_ptr 
- auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中
- STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，auto_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源
- 移一个auto_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空

## 3 空指针，悬垂指针，野指针，未初始化的指针
- 空指针：被赋值为null的指针，可以被多次delete
- 悬垂指针，野指针：指针指向的对象已经失效，无法通过判断是否为空来确认是否已经失效
- 未初始化的指针：不知道指向哪里，未知错误

## 4 常量指针和指针常量的区别？
常量指针：是一个指向常量的指针。可以防止对指针误操作而修改该常量
指针常量：是一个常量，且是一个指针。指针常量不能修改指针所指向的地址，一旦初始化，地址就固定了，不能对它进行移动操作。但是指针常量的内容是可以改变

## 5 指针与引用
- 引用：在创建的同时必须初始化，保证引用的对象是有效的，所以不存在null引用，比指针安全
- 指针：在定义的时候不必初始化，所以，指针则可以是NULL，可以在定义后面的任何地方重新赋值
- 引用：一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用
- 指针：在任何时候都可以改变为指向另一个对象
- 引用：创建和销毁并不会调用类的拷贝构造函数
- 指针：看情况，如果是创建一个空指针就不需要，看怎么创建；用delete删除指针是会调用析构函数的
- 由于const 指针仍然存在空指针，并且有可能产生野指针，所以还是不安全
- 指针是一个实体，有自己的空间，但是引用没有
- 指针使用++是对地址进行操作，而引用是对值进行自增

## 6 指针数组和数组指针
- 指针数组：数组，存储的是指针
```
char *arr[4] = {"hello", "world", "shannxi", "xian"};
//arr是一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。
```
- 数组指针：指针，指向数组
```
int a[3][4];
int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][],这个一维数组的长度是n，也可以说是p的步长,执行p+1时，p要跨过n个整型数据的长度因此，数组指针也称指向一维数组的指针，亦称行指针
```

## 7 函数指针和指针函数
- 指针函数：函数，返回值为指针，例如：int *f(x，y);
- 函数指针：指针，指向函数，例如：int (*f) (int x);
- 判断方法：*号被（）包含为函数指针，否则为指针函数
```
int funcA(int a,int b);
int (*func)(int,int);
func = funcA;//或者 func = &funcA;
```

## 8 C++是不是类型安全的？
不是。两个不同类型的指针之间可以强制转换



