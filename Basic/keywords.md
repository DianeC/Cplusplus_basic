## 关键字整理 
### 1 extern
- extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。
- 当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!
- 当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。
- 解释第二个用法：在头文件中声明，在cpp中定义（一次），外部链接性
- 与static的区别：static在声明时自动被定义，具有内部链接性
- const是内部链接性，但是在前面加上extern可以改变为外部连接性
- extern和static可以组合使用吗，没有见过**问题**

### 2 register
- register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度
- C++11中，提示是自动变量（不作专门说明的局部变量），避免该关键字成为非法

### 3 volatile **重要：仅为了提示编译器**
- volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的 memory barrier
- 用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问
- 指读取过程中，需要从内存读取，而不是读取在寄存器中的拷贝

### 4 mutable **重要：改变可不可变这一特性**
- mutable是为了突破const的限制而设置的，被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中

### 5 noexcept
- 该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化
- 如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序

### 6 explicit
- 修饰类的构造函数
- 被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换
- 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色，1 是个构造；2 是个默认且隐含的类型转换操作符
- explicit指在一个参数的构造函数中使用才有意义，因为多个参数的情况下不会发生隐式转换

### 7 auto，decltype
- http://c.biancheng.net/view/7158.html

### 8 final
- 禁用类继承：class Student final{};//被继承时编译报错
- 禁用类重写：virtual void someMethod() final;//派生类重写编译报错