## 1 多线程相关的类及其存在的意义
- 互斥量：控制线程对公共资源的访问，有上锁和解锁的功能
- 锁：像智能指针一样，管理互斥量，提供自动解锁功能，以免出现意外没有解锁，lock_guard unique_lock
- 条件变量：对多线程什么时候启用和阻塞提供控制
- 信号量：控制启用线程的数量
- future：线程异步的通信
- thread：管理线程资源

## 2 进程和线程的区别

## 3 进程和程序的区别

## 4 IO

## 5 同步IO和异步IO

## 6 原子变量和原子操作
- 在多线程模式下为了保证线程安全，我们通常做法是给共享资源加互斥锁，在一段时间只能有一个线程访问并操作共享资源，其他线程都会阻塞，这样就在一些对性能要求很高的情况下可能加锁就显得有点过重，于是就想出能不能在汇编层面让系统来能保证线程不乱来，让一个线程能把它想做的事做完其他线程再来操作，这就引出原子操作的概念
- 原子操作：就是将一系列操作能看成一个原子，不可分割，要么每个步骤都完成，要么都不做，同时能够按照顺序进行
- i++问题：包含了三个步骤，先是取i的值到寄存器中，然后是在寄存器中加1，然后又将值读回内存中
- 由于编译器不同等级的优化和cpu的乱序执行，一个线程内的指令执行顺序可能会发生变化，即**指令重排**，在线程A中变量a和变量b是不相关的，编译器就不会注重她两谁先谁后，可能就会先进行if语句，再执行a的定义语句，但可以看到这样就会影响线程B执行的结果。试想这种情况可不可以明确告诉编译器对变量的读写操作顺序不能乱来，这个就可以通过**内存序**来实现，c++11引入了6种内存序
- 指令重排
- 6种内存序：用于控制变量在不同线程间的顺序可见性
  - memory_order_relaxed：不对执行顺序做保证，编译器和处理器可以随意优化
  - memory_order_consume：防止在其后对原子变量有依赖的操作被重排到前面去
  - memory_order_acquire：要求当前调用之后的读写操作不会重排到前面来
  - memory_order_release：要求这个调用之前的读写操作不能重排到后面去
  - memory_order_acq_rel：读取-修改-写回
  - memory_order_seq_cst：默认的内存序
- 使用原子变量int，可以不用加锁进行自增和自减，耗时会远低于加锁自增
### 6.1 原子变量是什么
### 6.2 哪些运算符是原子操作
- 赋值：赋确定的值，是一条机器指令，是原子型
- i++：三条机器指令，取i的值到寄存器中，然后是在寄存器中加1，然后又将值读回内存中，不是原子型
- 用变量赋值：从实际执行的二进制指令来看，由于现代计算机CPU架构体系的限制，数据不可以直接从内存搬运到另外一块内存，必须借助寄存器中断，这条语句一般对应两条计算机指令，即将变量b的值搬运到某个寄存器(如eax)中，再从该寄存器搬运到变量a的内存地址
### 6.3 原子变量和加锁的区别

## 7 产生死锁的原因
- 对一个互斥量重复加锁
- 持有锁a的线程1请求锁b，持有锁b的线程2请求锁a
- 避免死锁：
  - 保证资源获取的顺序
  - 得不到所需资源时，放弃已有资源，等待

## 8 处理死锁



4、i++是原子操作吗？
答：不是，i++分为三个阶段：①从内存读取到寄存器；②寄存器数值自增；③寄存器写回内存。

其每个阶段之间都可以被打断，故不是原子操作。

78、死锁及其预防和处理方法
死锁的规范定义如下：如果一个进程在等待只能由该进程停止才能引发的事件，那么该进程就是死锁的。

（1）产生死锁的原因
因为系统资源不足。
进程运行推进的顺序不合适。
资源分配不当等。

（2）产生死锁的四个必要条件
互斥条件：每个资源要么已经分配给了一个进程，要么就是可用的。
占有和等待条件：已经得到了某个资源的进程可以再请求新的资源。
不可抢占条件：已经分配给一个进程的资源不能强制性地被抢占，只能被占有它的进程显式地释放；
环路等待条件：死锁发生时，系统中一定有两个或者两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

（3）处理死锁的四种策略：
鸵鸟策略（忽略死锁）；
检测死锁并恢复；
仔细对资源进行分配，动态地避免死锁；
通过破坏引起死锁的四个必要条件之一，防止死锁的产生。
（4）死锁避免
死锁避免的主要算法是基于一个安全状态 的概念。在任何时刻，如果没有死锁发生，并且即使所有进程忽然请求对资源的最大请求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。从安全状态出发，系统能够保证所有进程都能完成，而从不安全状态出发，就没有这样的保证。银行家算法 ：判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求，如果满足请求后系统仍然是安全的，就予以分配。不安全状态不一定引起死锁，因为客户不一定需要其最大贷款额度。


80、进程和线程的区别？进程和程序的区别？
进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。
进程和程序的区别
进程是动态的，而程序是静态的。

进程有一定的生命期，而程序是指令的集合，本身无“运动”的含义。没有建立进程的程序不能作为1个独立单位得到操作系统的认可。1个程序可以对应多个进程，但1个进程只能对应1个程序。进程和程序的关系犹如演出和剧本的关系。


问18：同步IO和异步IO的区别？
答：

A. 同步

所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。

按照这个定义，其实绝大多数函数都是同步调用（例如sin isdigit等）。

但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。

最常见的例子就是 SendMessage。

该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。

当对方处理完毕以后，该函数才把消息处理函数所返回的值返回给调用者。

B. 异步

异步的概念和同步相对。

当一个异步过程调用发出后，调用者不会立刻得到结果。

实际处理这个调用的部件是在调用发出后，通过状态、通知来通知调用者，或通过回调函数处理这个调用。

20. 死锁的产生
21. 进程和线程