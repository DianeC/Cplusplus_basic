11、 线程安全（单例模式， 懒汉，饿汉）
单例大约有两种实现方法：懒汉与饿汉。
懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化，
饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。

（1）饿汉

饿汉单例，即在最开始的时候，静态对象就已经创建完成；
设计方法是类中包含一个静态成员指针，该指针指向该类的一个对象，提供一个公有的静态成员方法，返回该对象指针；为了使得对象唯一，还需要将构造函数设为私有，

（2）懒汉

所谓懒汉模式，就是尽可能晚的创建这个对象的实例，即在单例类第一次被引用时将自己初始化；其实C++里很多地方都是类似这样的思想，比如晚绑定，写时拷贝技术等，就是尽量使资源的利用最大化，不要让空闲的人还占着有限的资源。

（3）懒汉的线程安全问题

如果此时多线程进行操作，简单点以两个线程为例，假设pthread_1刚判断完 intance 为NULL 为真，准备创建实例的时候，切换到了pthread_2, 此时pthread_2也判断intance为NULL为真，创建了一个实例，再切回pthread_1的时候继续创建一个实例返回，那么此时就不再满足单例模式的要求了， 既然这样，是因为多线程访问出的问题，那我们就来加把锁，使得线程同步；

单例模式的适用场景
（1）系统只需要一个实例对象，或者考虑到资源消耗的太大而只允许创建一个对象。
（2）客户调用类的单个实例只允许使用一个公共访问点，除了该访问点之外不允许通过其它方式访问该实例 (就是共有的静态方法)。

我用到了哪些设计模式

简单工厂模式
单一职责模式
代理模式
单例模式